\documentclass{beamer}
\usepackage{fancyvrb}
\usepackage{hyperref}
\usepackage{alltt}

\usepackage{graphicx}
\newtheorem{theo}{Theorem}[section]

\newcommand{\myfig}[1]{\centerline{\includegraphics[scale=0.25]{figures/#1.png}}}

\newcommand{\trans}[5]{
\begin{tabular}{|c|c|c|c|c|}\hline
#1 & #2 & #3 & #4 & #5 \\\hline
\end{tabular}
}

\newcommand{\arr}{&\rightarrow&}
\newcommand{\darr}{&\Rightarrow&}
\newcommand{\ar}{\rightarrow}
\newcommand{\dar}{\Rightarrow}
\newcommand{\bee}{\begin{eqnarray*}}
\newcommand{\eee}{\end{eqnarray*}}
\newcommand{\lmb}{\ensuremath{\lambda}}

\newcommand{\bi}{\begin{itemize}}
\newcommand{\li}{\item}
\newcommand{\ei}{\end{itemize}}

\newcommand{\sect}[1]{
\section{#1}
\begin{frame}[fragile]\frametitle{#1}
}

\mode<presentation>
{
%  \usetheme{Madrid}
  % or ...

%  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}

\usepackage[english]{babel}

\usepackage[latin1]{inputenc}

\title[Notes on LL Parsing]
{
Notes on LL Parsing
}

\subtitle{} % (optional)

\author[Geoffrey Matthews]
{Geoffrey Matthews}
% - Use the \inst{?} command only if the authors have different
%   affiliation.

\institute[WWU/CS]
{
  Department of Computer Science\\
  Western Washington University
}
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date{\today}

% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

%\pgfdeclareimage[height=0.5cm]{university-logo}{WWULogoProColor}
%\logo{\pgfuseimage{university-logo}}

% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

%\beamerdefaultoverlayspecification{<+->}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}


\newcommand{\myref}[1]{\small\item\url{#1}}
\newcommand{\myreft}[1]{\footnotesize\item\url{#1}}

%\begin{frame}
%  \frametitle{Outline}
%  \tableofcontents
%  % You might wish to add the option [pausesections]
%\end{frame}

\sect{Readings}

\begin{itemize}

\myreft{http://www.cs.rochester.edu/~nelson/courses/csc_173/grammars/cfg.html}

\myreft{http://en.wikipedia.org/wiki/Context-free_grammar}

\myreft{http://en.wikipedia.org/wiki/Context-free_language}
\myreft{http://en.wikipedia.org/wiki/Parsing}

\myreft{http://en.wikipedia.org/wiki/Pushdown_automata}
\myreft{http://en.wikipedia.org/wiki/LR_parser}
\myreft{https://parasol.tamu.edu/~rwerger/Courses/434/lec12-sum.pdf}
\end{itemize}

\end{frame}

\sect{Top-down Parsing of CFGs}
\begin{columns}
\column{0.6\textwidth}
\bi
\li We start with the input and attempt to build the parse tree.
\li If we begin with the start symbol and attempt to build the tree
below it, we are doing {\bf top-down} parsing.
\li Equivalently, we try to constuct a leftmost derivation from left
to right.
\ei
\column{0.4\textwidth}
\bee
S \arr AS\ | \ \lambda\\
A \arr AA\ | \ a
\eee
\myfig{derivationtree}
\end{columns}
\vfill
\[
S \Rightarrow AS \Rightarrow AAS \Rightarrow aAS \Rightarrow aaS \Rightarrow aa
\]
\end{frame}

\sect{$LL(k)$ grammars}
\bi
\li We use the same trick we used to show every CFG has an equivalent PDA:
\bi
\li Start with $S$ on the stack
\li Pop nonterminals and replace them with a rule RHS
\li Match terminals on the stack with terminals on the input
\ei
\li The trick is knowing which rule to use when we pop a nonterminal
\li $LL(k)$ means we find a leftmost derivation by scanning the input
left to right, and have to lookahead at most $k$ symbols.
\li With $LL(1)$, we construct a chart showing, for any given
(input,nonterminal) pair, which rule to use. 
\ei
\end{frame}

\sect{An $LL(1)$ grammar and chart for $a^nbc^n$}
\begin{columns}
\column{0.5\textwidth}
\[ S \ar aSc\ | \ b \]

\[ aabcc \]

\bee
S \darr aSc\\
  \darr aaScc \\
  \darr aabcc
\eee
\vfill
\begin{tabular}{|c|c|c|c|c|}\hline
  & a & b & c & \$ \\\hline
S & $S\ar aSc$ & $S\ar b$ & & \\\hline
\end{tabular}
\column{0.5\textwidth}

\begin{tabular}{|l|r|l|}\hline
Stack & Input & Rule \\\hline
\$S & aabcc\$ & $S\ar aSc$ \\\hline
\$cSa & aabcc\$ & match \\\hline
\$cS & abcc\$ & $S\ar aSc$\\\hline
\$ccSa & abcc\$ & match\\\hline
\$ccS & bcc\$ & $S\ar b$\\\hline
\$ccb & bcc\$ & match \\\hline
\$cc & cc\$ & match \\\hline
\$c & c\$ & match \\\hline
\$ & \$ & accept \\\hline
\end{tabular}

\end{columns}

\end{frame}

\sect{Another $LL(1)$ grammar and chart}
\footnotesize
\begin{columns}
\column{0.6\textwidth}
\bee 
S \arr ASb \ | \ C\\
A \arr a \\
C \arr cC \ | \ \lambda\\
S \darr ASb \\
\darr aSb\\
\darr aASbb \\
\darr aaSbb\\
\darr aaCbb\\
\darr aacCbb\\
\darr aaccCbb\\
\darr aaccbb
\eee
\vfill
\begin{tabular}{|c|c|c|c|c|}\hline
  & a & b & c & \$ \\\hline
S & $S\ar ASb$ &  & $S\ar C$ & $S\ar C$ \\\hline
A & $A\ar a$ &  &  & \\\hline
C &  & $C\ar \lmb$ & $C\ar cC$ & $C\ar \lmb$ \\\hline
\end{tabular}
\column{0.4\textwidth}

\begin{tabular}{|l|r|l|}\hline
Stack & Input & Rule \\\hline
\$S & aaccbb\$ & $S\ar ASb$ \\\hline
\$bSA & aaccbb\$ & $A\ar a$ \\\hline
\$bSa & aaccbb\$ & match \\\hline
\$bS & accbb\$ & $S\ar ASb$ \\\hline
\$bbSA & accbb\$ & $A\ar a$ \\\hline
\$bbSa & accbb\$ & match \\\hline
\$bbS & ccbb\$ & $S\ar C$ \\\hline
\$bbC & ccbb\$ & $C \ar cC$ \\\hline
\$bbCc & ccbb\$ & match \\\hline
\$bbC & cbb\$ & match \\\hline
\$bbC & cbb\$ & $C\ar cC$ \\\hline
\$bbCc & cbb\$ & match \\\hline
\$bbC & bb\$ & $C\ar \lmb$ \\\hline
\$bb & bb\$ & match \\\hline
\$b & b\$ & match \\\hline
\$ & \$ & accept \\\hline
\end{tabular}

\end{columns}

\end{frame}

\sect{$LL(1)$ parsing by recursive descent}
\begin{columns}
\column{0.5\textwidth}
\[ S \ar aSc\ | \ b \]

\[ aabcc \]

\bee
S \darr aSc\\
  \darr aaScc \\
  \darr aabcc
\eee
\vfill
\begin{tabular}{|c|c|c|c|c|}\hline
  & a & b & c & \$\\\hline
S & $S\ar aSc$ & $S\ar b$ & & \\\hline
\end{tabular}
\column{0.5\textwidth}
\begin{alltt}
(define (S)
  (cond 
    ((front? 'a)
     (displayln "S -> aSc")
     (match 'a)
     (S)
     (match 'c))
    ((front? 'b)
     (displayln "S -> b")
     (match 'b))
    (else
     (error))))
\end{alltt}
\end{columns}

\end{frame}
\sect{$LL(1)$ parsing by recursive descent}
\footnotesize
\begin{columns}
\column{0.5\textwidth}
\bee 
S \arr ASb \ | \ C\\
A \arr a \\
C \arr cC \ | \ \lambda\\
S \darr ASb \\
\darr aSb\\
\darr aASbb \\
\darr aaSbb\\
\darr aaCbb\\
\darr aacCbb\\
\darr aaccCbb\\
\darr aaccbb
\eee
\vfill
\begin{tabular}{|c|c|c|c|c|}\hline
  & a & b & c & \$ \\\hline
S & $S\ar ASb$ &  & $S\ar C$ & $S\ar C$ \\\hline
A & $A\ar a$ &  &  & \\\hline
C &  & $C\ar \lmb$ & $C\ar cC$ & $C\ar \lmb$ \\\hline
\end{tabular}
\column{0.5\textwidth}
\begin{alltt}
(define (S2)
  (cond ((front? 'a)
         (A) (S2) (match 'b))
        ((front? 'c) 
         (C))
        ((front? '$)
         (C))
        (else (error))))
(define (A)
  (cond ((front? 'a)
         (match 'a))
        (else (error))))
(define (C)
  (cond ((front? 'b)  )
        ((front? 'c)
         (match 'c) (C))
        ((front? '$)  )
        (else (error))))
\end{alltt}
\end{columns}

\end{frame}

\sect{A non-$LL(1)$ grammar for $a^mb^nc$, $m\geq 1$ and $n \geq 0$}
\begin{columns}
\column{0.5\textwidth}
\bee
S \arr AB\\
A \arr aA\ | \ a\\
B \arr bB\ | \ c
\eee
\column{0.5\textwidth}
\bee
S \darr AB\\
  \darr aAB\\
  \darr aaB\\
  \darr aabB\\
  \darr aabbB\\
  \darr aabbc
\eee
\end{columns}
\bigskip

\bi
\li Need to see two letters to determine which production to use.
\ei

\end{frame}

\sect{Sometimes we can find $LL(1)$ to replace a non-$LL(1)$}
\begin{columns}
\column{0.5\textwidth}
\bee
S \arr AB\\
A \arr aA\ | \ a\\
B \arr bB\ | \ c
\eee
\column{0.5\textwidth}
\bee
S \arr aAB\\
A \arr aA \ | \ \lmb\\
B \arr bB \ | \ c
\eee
\end{columns}
\bigskip
\bi
\li Same language, different grammars.
\li $LL(1)$ is a property of {\bf grammars}, not {\bf languages}.
\ei


\end{frame}

\sect{An $LL(k)$ grammar whose language has no $LL(k-1)$ grammar}
\bee
S \arr aSA \ | \ \lmb\\
A \arr a^{k-1}bS \ | \ c
\eee
\end{frame}

\sect{A deterministic language with no $LL(k)$ grammar}
\[
\{a^n \ | \ n \geq 0\} \cup \{a^nb^n \ | \ n \geq 0\}
\]
\vfill

\myfig{detbutnotllk}
\vfill

\end{frame}



\sect{An $LL(1)$ grammar without terminals on RHS}
\bee
S\arr A \ | \ B\\
A \arr aA \ | \ \lambda\\
B \arr bB \ | \ c
\eee
\begin{center}
\begin{tabular}{|c|c|c|c|c|}\hline
 & a & b & c & \$\\\hline
S & $S\ar A$ & $S\ar B$ & $S \ar B$ & $S\ar A$\\\hline
A & $A\ar aA$ &  && $A\ar\lmb$\\\hline
B && $B\ar bB$ & $B\ar c$&\\\hline
\end{tabular}
\end{center}
\end{frame}



\sect{Transforming some $LL(k)$ to $LL(1)$ by Left-Factoring}
\begin{columns}
\column{0.5\textwidth}
\bee
S \arr abcX \ | \ abcY\\
X \arr xX \ | \ x\\
Y \arr yY \ | \ y
\eee
\column{0.5\textwidth}
\bee
S \arr aB\\
B \arr bC\\
C \arr cX \ | \ cY\\
X \arr xX \ | \ x\\
Y \arr yY \ | \ y
\eee
\end{columns}

\end{frame}

\sect{Left recursion is not $LL(k)$}
\begin{columns}
\column{0.5\textwidth}
\[
A \ar Aa \ | \ b
\]
\bi
\li The entire input must be read before we know how many times to
apply the first rule, before we apply the second.
\ei
\column{0.5\textwidth}
\bee
A \darr Aa\\
  \darr Aaa\\
  \darr Aaaa\\
  \darr \ldots\\
  \darr Aaaaaaaaaaaaaaaaaaaaa\\
  \darr baaaaaaaaaaaaaaaaaaaa
\eee
\end{columns}

\end{frame}

\sect{Immediate left recursion can be removed}
\bee
A \arr Aw \ | \ y
\eee

\bi
\pause \li Any string in the language must start with a $y$ followed by 0 or
more $w$'s
\ei

\pause 
\bee
A \arr yB \\
B \arr wB \ | \ \lambda
\eee

\vfill

\end{frame}

\sect{More general immediate left recursion}
\bee
A \arr Aw_1 \ | \ Aw_2 \ | \ \ldots \ | \ Aw_{n} \ | \ x_1 \ | \ x_2
\ | \ \ldots \ | \ x_m
\eee

\pause 
\bee
A \arr x_1B \ | \ x_2B \ | \ \ldots \ | \ x_mB\\
B \arr w_1B \ | \ w_2B \ | \ \ldots \ | \ w_nB \ | \ \lambda
\eee

\vfill

\end{frame}

\sect{Removing left recursion example}

\bee
A \arr Aa \ | \ b
\eee

\bee 
A \arr bB \\
B \arr aB \ | \ \lambda
\eee
\end{frame}

\sect{Removing left recursion from arithmetic, (a + a) * a}
\begin{columns}
\column{0.5\textwidth}
\bee
E \arr E + T \ | \ T\\
T \arr T * F \ | \ F\\
F \arr ( E ) \ | \ a
\eee

\vspace{1cm}

\bi
\li Note we get the phrase structure of the expression reflected in
the tree.
\li What kind of tree do we get from a + a + a?
\li How could we make it right associative?
\ei

\column{0.5\textwidth}
\myfig{arithmetictree1}
\end{columns}

\end{frame}

\sect{Remove the left recursion}
\begin{columns}
\column{0.5\textwidth}
\bee
E \arr E + T \ | \ T\\
T \arr T * F \ | \ F\\
F \arr ( E ) \ | \ a
\eee
\column{0.5\textwidth}
\bee 
E \arr TR\\
R \arr +TR \ | \ \lambda\\
T \arr FV \\
V \arr *FV \ | \ \lambda \\
F \arr (E) \ | \ a
\eee
\end{columns}
\vfill

\end{frame}

\sect{What happened to the tree?}
\begin{columns}
\column{0.25\textwidth}
\bee 
E \arr TR\\
R \arr +TR \ | \ \lambda\\
T \arr FV \\
V \arr *FV \ | \ \lambda \\
F \arr (E) \ | \ a
\eee
\column{0.75\textwidth}
\myfig{arithmetictree2}
\end{columns}
\vfill

\end{frame}

\sect{Indirect left recursion}

\bee
S \arr Bb\\
B \arr Sa \ | \ a
\eee
\[
S \dar Bb \dar Sab
\]

\end{frame}

\sect{Removing indirect left recursion}
\bee
S \arr Bb\\
B \arr Sa \ | \ a
\eee
Replace $B$'s RHS in $S$'s RHS:
\bee
S \arr Sab \ | \ ab
\eee
Now remove the immediate left recursion
\bee
S \arr abT\\
T \arr abT \ | \ \lambda
\eee
\end{frame}


\sect{Removing indirect left recursion}

\begin{columns}
\column{0.5\textwidth}
\bee
A \arr Bb \ | \ e\\
B \arr Cc \ | \ f\\
C \arr Ad \ | \ g
\eee

\vspace{1in}

\bi
\li This method can be applied generally, but the rules multiply.
\ei

\column{0.5\textwidth}
1. Replace $B$'s RHS in $A$'s RHS:
\bee
A \arr Ccv \ | \  fb \ | \  e
\eee
2. Now replace $C$'s RHS
\bee
A \arr Adcb \ | \ gcb \ | \  fb \ | \  e
\eee
3. Now remove the immediate left recursion
\bee
A \arr gcbD \ | \ fbD \ | \ eD\\
D \arr dcbD \ | \ \lambda
\eee

\end{columns}



\vfill

\end{frame}

\sect{$LL(k)$ problems}
Find an $LL(1)$ grammar and parse table for the following languages
\begin{itemize}
\li $\{a, ba, bba\}$
\li $a^*b$
\li $a^{n+1}bc^{n}$
\li $a^mb^nc^{m+n}$
\end{itemize}

\end{frame}


\end{document}
